syntax = "proto3";

package kurrentdb.protocol.v2;

option csharp_namespace    = "KurrentDB.Protocol.Streams.V2";
option java_package        = "io.kurrentdb.protocol.streams.v2";
option java_multiple_files = true;

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/descriptor.proto";

import "streams/error_details.proto";
import "core.proto";

service StreamsReadService {
  // Retrieve batches of records continuously.
  rpc ReadSession(ReadRequest) returns (stream ReadResponse);

  // Retrieve batches of records continuously.
  rpc Read(ReadRequest) returns (stream ReadResponse);
}

//===================================================================
// Read Operations
//===================================================================

// The scope of the read filter determines where the filter will be applied.
enum ReadFilterScope {
  READ_FILTER_SCOPE_UNSPECIFIED = 0;
  // The filter will be applied to the record stream name
  READ_FILTER_SCOPE_STREAM = 1;
  // The filter will be applied to the record schema name
  READ_FILTER_SCOPE_SCHEMA_NAME = 2;
  // The filter will be applied to the properties of the record
  READ_FILTER_SCOPE_PROPERTIES = 3;
  // The filter will be applied to all the record properties
  // including the stream and schema name
  READ_FILTER_SCOPE_RECORD = 4;
  // The filter will be applied to the index name
  READ_FILTER_SCOPE_INDEX_NAME = 5;
}

// The filter to apply when reading records from the database
// The combination of stream scope and literal expression indicates a direct stream name match,
// while a regex expression indicates a pattern match across multiple streams.
message ReadFilter {
  // The scope of the filter.
  ReadFilterScope scope = 1;
  // The expression can be a regular expression or a literal value.
  // If it starts with "~" it will be considered a regex.
  string expression = 2;
}

// Record retrieved from the database.
message Record {
  // The unique identifier of the record in the database.
  string record_id = 1;
  // The position of the record in the database.
  int64 position = 5;
  // The actual data payload of the record, stored as bytes.
  bytes data = 2;
  // Additional information about the record.
  map<string, DynamicValue> properties = 3;
  // When the record was created.
  google.protobuf.Timestamp timestamp = 4;
  // The stream to which the record belongs.
  optional string stream = 6;
  // The revision of the stream created when the record was appended.
  optional int64 stream_revision = 7;
}

// The direction in which to read records from the database (forwards or backwards).
enum ReadDirection {
  READ_DIRECTION_FORWARDS  = 0;
  READ_DIRECTION_BACKWARDS = 1;
}

// Initial position at which the cursor will be set when subscribing.
enum ReadInitialPosition {
  READ_INITIAL_POSITION_LATEST   = 0;
  READ_INITIAL_POSITION_EARLIEST = 1;
}

// Limit how many records can be retrieved.
message ReadLimit {
  // The maximum number of records to return.
  // If not specified, an active read session will be created
  // and the client will receive records as they are appended to the stream.
  optional uint64 count = 1;
}

// Represents the successful outcome of a read operation.
message ReadSuccess {
  repeated Record records = 1;
}

// Represents the detailed error information when a read operation fails.
message ReadFailure {
  // The error details
  oneof error {
    // Failed because the client lacks sufficient permissions.
    CoreErrorDetails.AccessDenied access_denied = 1;
    // Failed because the target stream has been deleted.
    StreamsErrorDetails.StreamDeleted stream_deleted = 2;
    // Failed because the stream has been tombstoned.
    StreamsErrorDetails.StreamTombstoned stream_tombstoned = 4;
    // Failed because the expected stream revision did not match the actual revision.
    StreamsErrorDetails.StreamNotFound stream_not_found = 3;
  }
}

// Read request message that contains the filter, starting position, limit,
// direction, and heartbeat options for reading records from the database.
// It allows the client to specify how to read records, including the filter to apply,
// the starting position, the maximum number of records to return, the direction of reading,
// and whether to enable heartbeats for monitoring session health.
// The batch size can also be specified to control how many records are read in a single batch.
message ReadRequest {
  // The filter to apply when reading records.
  optional ReadFilter filter = 1;
  // The starting position of the log from which to read records.
  optional int64 start_position = 2;

  // Position at which the cursor will be set when subscribing.
  // Used when no start position is specified.
  // If not specified, the default is READ_INITIAL_POSITION_LATEST.
  ReadInitialPosition initial_position = 7;

  // Limit how many records can be returned.
  // This will get capped at the default limit,
  // which is up to 1000 records.
  optional int64 limit = 3;
  // The direction in which to read the stream (forwards or backwards).
  ReadDirection direction = 4;
  // Heartbeats can be enabled to monitor end-to-end session health.
  HeartbeatOptions heartbeats = 5;
  // The number of records to read in a single batch.
  int32 batch_size = 6;
}

// Read response message that can contain either a successful read result,
// a failure result, or a heartbeat message.
// This allows the client to handle different outcomes of the read operation.
message ReadResponse {
  oneof result {
    // Success represents the successful outcome of an read operation.
    ReadSuccess success = 1;
    // Failure represents the details of a failed read operation.
    ReadFailure failure = 2;
    // Heartbeat represents the health check of the read operation when
    // the server has not found any records matching the filter for the specified
    // period of time or records threshold.
    // A heartbeat will be sent when the initial switch to real-time tailing happens.
    Heartbeat heartbeat = 3;
  }
}

// A health check will be sent when the server has not found any records
// matching the filter for the specified period of time or records threshold. A
// heartbeat will be sent when the initial switch to real-time tailing happens.
message HeartbeatOptions {
  // Enable heartbeats for monitoring end-to-end session health.
  // If enabled, heartbeats will be sent periodically or when the records threshold is reached.
  // If disabled, no heartbeats will be sent.
  bool enable = 1;
  // The period after which a heartbeat will be sent if no records are found.
  // If not specified, the default period is 30 seconds.
  // This is the maximum time to wait before sending a heartbeat.
  // If the period is set to 0, heartbeats will not be sent based on time.
  // If the period is set to a non-zero value, heartbeats will be sent
  optional google.protobuf.Duration period            = 2;  // 30 seconds
  optional int32                    records_threshold = 3;  // 500
}

// The type of heartbeat sent by the server to indicate the status of the read operation.
// It can indicate whether the subscription is caught up, fell behind, or
// the filter has not been satisfied after a period of time or records threshold.
enum HeartbeatType {
  HEARTBEAT_TYPE_UNSPECIFIED = 0;
  HEARTBEAT_TYPE_CHECKPOINT  = 1;
  HEARTBEAT_TYPE_CAUGHT_UP   = 2;
  HEARTBEAT_TYPE_FELL_BEHIND = 3;
}

// Heartbeat message sent by the server to indicate the status of the read operation.
// It contains the type of heartbeat, the position for resuming reads,
// and the timestamp when the heartbeat was sent.
message Heartbeat {
  // This indicates whether the subscription is caught up, fell behind, or
  // the filter has not been satisfied after a period of time or records threshold.
  HeartbeatType type = 1;
  // Checkpoint for resuming reads.
  // It will always be populated unless the database is empty.
  int64 position = 2;
  // When the heartbeat was sent.
  google.protobuf.Timestamp timestamp = 3;
}

//===================================================================
