using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Kurrent.Whatever.SourceGenerators;

[Generator]
public class WhateverGenerator : ISourceGenerator {
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context) {
        var compilation = context.Compilation;

        foreach (var syntaxTree in compilation.SyntaxTrees) {
            var semanticModel = compilation.GetSemanticModel(syntaxTree);

            var root = syntaxTree.GetRoot();

            foreach (var classDeclaration in root.DescendantNodes().OfType<ClassDeclarationSyntax>()) {
                var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
                if (classSymbol == null) continue;

                if (ImplementsIWhateverDirectly(classSymbol, out var genericTypeArguments))
                    if (genericTypeArguments.Any()) {
                        var source = GenerateWhateverImplementation(classSymbol, genericTypeArguments);
                        if (!string.IsNullOrEmpty(source)) {
                            var sanitizedTypeArguments = string.Join("_", genericTypeArguments.Select(GetSafeFileNameFromType));
                            var fullTypeNameForFile    = $"{classSymbol.Name}_{sanitizedTypeArguments}";
                            var namespaceForFile       = classSymbol.ContainingNamespace.IsGlobalNamespace ? "Global" : classSymbol.ContainingNamespace.ToDisplayString().Replace('.', '_');

                            context.AddSource($"{namespaceForFile}_{fullTypeNameForFile}_Whatever.g.cs", SourceText.From(source, Encoding.UTF8));
                        }
                    }
            }
        }
    }

    string GetSafeFileNameFromType(ITypeSymbol typeSymbol) {
        var simpleName = GetCleanTypeName(typeSymbol);
        return simpleName
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace(" ", "_")
            .Replace("?", "_nullable");
    }

    bool ImplementsIWhateverDirectly(INamedTypeSymbol classSymbol, out List<ITypeSymbol> genericTypeArguments) {
        genericTypeArguments = new List<ITypeSymbol>();
        foreach (var implementedInterface in classSymbol.Interfaces)
            if (implementedInterface.ContainingNamespace?.ToDisplayString() == "Kurrent.Whatever" &&
                implementedInterface.Name.StartsWith("IWhatever") &&
                implementedInterface.IsGenericType)
                genericTypeArguments.AddRange(implementedInterface.TypeArguments);

        return genericTypeArguments.Count != 0;
    }

    string GenerateWhateverImplementation(INamedTypeSymbol classSymbol, List<ITypeSymbol> typeArguments) {
        var className                  = classSymbol.Name;
        var minimallyQualifiedClassName = classSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var namespaceName              = classSymbol.ContainingNamespace.IsGlobalNamespace ? null : classSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        sb.AppendLine($"// <auto-generated by WhateverGenerator for {minimallyQualifiedClassName} @ {DateTime.UtcNow} />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName)) {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        var containingTypeSymbols = new List<INamedTypeSymbol>();
        var currentContainingType = classSymbol.ContainingType;
        while (currentContainingType != null) {
            containingTypeSymbols.Add(currentContainingType);
            currentContainingType = currentContainingType.ContainingType;
        }

        containingTypeSymbols.Reverse();

        foreach (var containingTypeSymbol in containingTypeSymbols) {
            sb.AppendLine($"partial class {containingTypeSymbol.Name}");
            sb.AppendLine("{");
        }

        var baseIndent = string.Concat(Enumerable.Repeat("    ", containingTypeSymbols.Count));
        sb.AppendLine($"{baseIndent}public partial class {className} : IEquatable<{className}>");
        sb.AppendLine($"{baseIndent}{{");
        var memberIndent = baseIndent + "    ";

        sb.AppendLine($"{memberIndent}private readonly object _value;");
        sb.AppendLine($"{memberIndent}private readonly int _index;");
        sb.AppendLine();

        for (var i = 0; i < typeArguments.Count; i++) {
            var typeArg                   = typeArguments[i];
            var typeArgNameForConstructor = typeArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var parameterName             = GetParameterName(typeArg);
            sb.AppendLine($"{memberIndent}public {className}({typeArgNameForConstructor} {parameterName})");
            sb.AppendLine($"{memberIndent}{{");
            if (!typeArg.IsValueType && typeArg.SpecialType != SpecialType.System_Nullable_T)
                if (typeArg.IsReferenceType)
                    sb.AppendLine($"{memberIndent}    if ({parameterName} == null) throw new ArgumentNullException(nameof({parameterName}));");

            sb.AppendLine($"{memberIndent}    _value = {parameterName};");
            sb.AppendLine($"{memberIndent}    _index = {i};");
            sb.AppendLine($"{memberIndent}}}");
        }

        sb.AppendLine();

        sb.AppendLine($"{memberIndent}public object Value => _value;");
        sb.AppendLine($"{memberIndent}public int Index => _index;");
        sb.AppendLine();


        // public global::Kurrent.Client.Model.ErrorDetails.StreamRevisionConflict AsStreamRevisionConflict => Index == 3
        //     ? (global::Kurrent.Client.Model.ErrorDetails.StreamRevisionConflict)Value!
        //     : throw new InvalidOperationException($"Cannot return as StreamRevisionConflict as current type is {Value?.GetType().Name ?? "unknown"} (Index {Index})");

        for (var i = 0; i < typeArguments.Count; i++) {
            var typeArg              = typeArguments[i];
            var typeArgNameForMember = typeArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var propertySuffix       = GetCleanTypeName(typeArg);
            sb.AppendLine($"{memberIndent}public bool Is{propertySuffix} => Index == {i};");
            sb.AppendLine($"{memberIndent}public {typeArgNameForMember} As{propertySuffix} => Index == {i}");
            sb.AppendLine($"{memberIndent}    ? ({typeArgNameForMember})Value!");
            sb.AppendLine($"{memberIndent}    : throw new InvalidOperationException($\"Cannot return as {propertySuffix} as current type is {{Value?.GetType().Name ?? \"unknown\"}} (Index {{Index}})\");");
            sb.AppendLine();
        }

        for (var i = 0; i < typeArguments.Count; i++) {
            var typeArg                = typeArguments[i];
            var typeArgNameForImplicit = typeArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var parameterName          = GetParameterName(typeArg);
            sb.AppendLine($"{memberIndent}public static implicit operator {minimallyQualifiedClassName}({typeArgNameForImplicit} {parameterName}) => new {minimallyQualifiedClassName}({parameterName});");
        }

        sb.AppendLine();

        for (var i = 0; i < typeArguments.Count; i++) {
            var typeArg                = typeArguments[i];
            var explicitReturnTypeName = typeArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var propertySuffix         = GetCleanTypeName(typeArg);
            var isValueType            = typeArg.IsValueType;

            var isTypeArgAlreadyNullable = typeArg.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

            var nullableSuffix     = isValueType && !isTypeArgAlreadyNullable ? "?" : "";
            var fullReturnTypeName = $"{explicitReturnTypeName}{nullableSuffix}";

            sb.AppendLine($"{memberIndent}public static explicit operator {fullReturnTypeName}({minimallyQualifiedClassName} whatever) => whatever.As{propertySuffix};");
        }

        sb.AppendLine();

        GenerateSwitchMethods(sb, memberIndent, typeArguments);
        GenerateMatchMethods(sb, memberIndent, typeArguments);
        GenerateTryPickMethods(sb, memberIndent, typeArguments);
        GenerateEqualityMembers(sb, memberIndent, className);

        sb.AppendLine($"{baseIndent}}}");
        for (var i = containingTypeSymbols.Count - 1; i >= 0; i--) sb.AppendLine(string.Concat(Enumerable.Repeat("    ", i)) + "}");
        return sb.ToString();
    }

    void GenerateEqualityMembers(StringBuilder sb, string indent, string className) {
        sb.AppendLine($"{indent}public bool Equals({className}? other)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    if (ReferenceEquals(null, other)) return false;");
        sb.AppendLine($"{indent}    if (ReferenceEquals(this, other)) return true;");
        sb.AppendLine($"{indent}    return _index == other._index && EqualityComparer<object>.Default.Equals(_value, other._value);");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();

        sb.AppendLine($"{indent}public override bool Equals(object? obj)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    return Equals(obj as {className});");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();

        sb.AppendLine($"{indent}public override int GetHashCode()");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    unchecked");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        return ((_value?.GetHashCode() ?? 0) * 397) ^ _index;");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();

        sb.AppendLine($"{indent}public static bool operator ==({className}? left, {className}? right)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    if (ReferenceEquals(left, null)) return ReferenceEquals(right, null);");
        sb.AppendLine($"{indent}    return left.Equals(right);");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();

        sb.AppendLine($"{indent}public static bool operator !=({className}? left, {className}? right)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    return !(left == right);");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();

        sb.AppendLine($"{indent}public override string? ToString() => _value?.ToString();");
        sb.AppendLine();
    }

    void GenerateSwitchMethods(StringBuilder sb, string indent, List<ITypeSymbol> typeArguments) {
        sb.Append($"{indent}public void Switch(");
        for (var i = 0; i < typeArguments.Count; i++) {
            var typeArg       = typeArguments[i];
            var cleanTypeName = GetCleanTypeName(typeArg);
            var paramName     = $"on{cleanTypeName}";
            // Ensure paramName is a valid identifier (e.g. if cleanTypeName had invalid chars, though GetCleanTypeName should sanitize)
            paramName = SanitizeIdentifier(paramName);
            if (SyntaxFacts.IsKeywordKind(SyntaxFacts.GetKeywordKind(paramName))) paramName = "@" + paramName;

            sb.Append($"Action<{typeArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}> {paramName}");
            if (i < typeArguments.Count - 1) sb.Append(", ");
        }

        sb.AppendLine(")");
        sb.AppendLine($"{indent}{{");
        for (var i = 0; i < typeArguments.Count; i++) {
            var typeArg        = typeArguments[i];
            var propertySuffix = GetCleanTypeName(typeArg);
            var cleanTypeName  = GetCleanTypeName(typeArg); // Re-get for consistency, though could reuse
            var paramName      = $"on{cleanTypeName}";
            paramName = SanitizeIdentifier(paramName);
            if (SyntaxFacts.IsKeywordKind(SyntaxFacts.GetKeywordKind(paramName))) paramName = "@" + paramName;

            sb.AppendLine($"{indent}    if (Index == {i}) {{ {paramName}?.Invoke(As{propertySuffix}); return; }}");
        }

        sb.AppendLine($"{indent}    throw new InvalidOperationException(\"Unhandled case in Switch statement.\");");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    void GenerateMatchMethods(StringBuilder sb, string indent, List<ITypeSymbol> typeArguments) {
        sb.Append($"{indent}public TResult Match<TResult>(");
        for (var i = 0; i < typeArguments.Count; i++) {
            var typeArg       = typeArguments[i];
            var cleanTypeName = GetCleanTypeName(typeArg);
            var paramName     = $"on{cleanTypeName}";
            paramName = SanitizeIdentifier(paramName);
            if (SyntaxFacts.IsKeywordKind(SyntaxFacts.GetKeywordKind(paramName))) paramName = "@" + paramName;

            sb.Append($"Func<{typeArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}, TResult> {paramName}");
            if (i < typeArguments.Count - 1) sb.Append(", ");
        }

        sb.AppendLine(")");
        sb.AppendLine($"{indent}{{");
        for (var i = 0; i < typeArguments.Count; i++) {
            var typeArg        = typeArguments[i];
            var propertySuffix = GetCleanTypeName(typeArg);
            var cleanTypeName  = GetCleanTypeName(typeArg);
            var paramName      = $"on{cleanTypeName}";
            paramName = SanitizeIdentifier(paramName);
            if (SyntaxFacts.IsKeywordKind(SyntaxFacts.GetKeywordKind(paramName))) paramName = "@" + paramName;

            sb.AppendLine($"{indent}    if (Index == {i}) return {paramName} != null ? {paramName}(As{propertySuffix}) : throw new ArgumentNullException(nameof({paramName}));");
        }

        sb.AppendLine($"{indent}    throw new InvalidOperationException(\"Unhandled case in Match statement.\");");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    void GenerateTryPickMethods(StringBuilder sb, string indent, List<ITypeSymbol> typeArguments) {
        for (var i = 0; i < typeArguments.Count; i++) {
            var pickType          = typeArguments[i];
            var pickTypeName      = pickType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var pickTypeCleanName = GetCleanTypeName(pickType);
            sb.AppendLine($"{indent}public bool TryPick{pickTypeCleanName}(out {pickTypeName} value)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    if (Index == {i})");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        value = As{pickTypeCleanName};");
            sb.AppendLine($"{indent}        return true;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}    value = default({pickTypeName})!;");
            sb.AppendLine($"{indent}    return false;");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine();
        }
    }

    string GetCleanTypeName(ITypeSymbol typeSymbol) {
        switch (typeSymbol.SpecialType) {
            case SpecialType.System_Boolean: return "Bool";

            case SpecialType.System_Byte: return "Byte";

            case SpecialType.System_SByte: return "SByte";

            case SpecialType.System_Char: return "Char";

            case SpecialType.System_Decimal: return "Decimal";

            case SpecialType.System_Double: return "Double";

            case SpecialType.System_Single: return "Float";

            case SpecialType.System_Int32: return "Int";

            case SpecialType.System_UInt32: return "UInt";

            case SpecialType.System_Int64: return "Long";

            case SpecialType.System_UInt64: return "ULong";

            case SpecialType.System_Int16: return "Short";

            case SpecialType.System_UInt16: return "UShort";

            case SpecialType.System_Object: return "Object";

            case SpecialType.System_String: return "String";
        }

        if (typeSymbol is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T, TypeArguments.Length: 1 } namedTypeSymbol)
            return GetCleanTypeName(namedTypeSymbol.TypeArguments[0]) + "Nullable";

        var name = typeSymbol.Name;
        if (typeSymbol is INamedTypeSymbol { IsGenericType: true } namedType) {
            if (namedType.OriginalDefinition.SpecialType != SpecialType.System_Nullable_T) name = namedType.Name + string.Join("", namedType.TypeArguments.Select(GetCleanTypeName));
        }
        else if (typeSymbol is IArrayTypeSymbol arrayType) {
            name = GetCleanTypeName(arrayType.ElementType) + "Array";
        }

        name = name.Replace(".", "").Replace("<", "").Replace(">", "").Replace(",", "").Replace(" ", "");
        if (string.IsNullOrEmpty(name) || name == "Nullable`1") {
            if (typeSymbol is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T, TypeArguments.Length: 1 } nt) return GetCleanTypeName(nt.TypeArguments[0]) + "Nullable";

            return "Type";
        }

        if (name.Length > 0 && char.IsDigit(name[0])) name = "_" + name;
        return SanitizeIdentifier(name);
    }

    string SanitizeIdentifier(string name) {
        if (string.IsNullOrEmpty(name)) return "_";

        var idBuilder = new StringBuilder();
        if (name.Length > 0 && !char.IsLetter(name[0]) && name[0] != '_') idBuilder.Append('_');
        foreach (var c in name)
            if (char.IsLetterOrDigit(c) || c == '_')
                idBuilder.Append(c);
            else
                idBuilder.Append('_');

        var result = idBuilder.ToString();
        if (string.IsNullOrEmpty(result)) return "GeneratedType";

        return result;
    }

    string GetParameterName(ITypeSymbol typeSymbol) {
        string paramNameBase;
        if (typeSymbol is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T, TypeArguments.Length: 1 } namedTypeSymbol)
            paramNameBase = GetParameterName(namedTypeSymbol.TypeArguments[0]) + "Opt";
        else
            switch (typeSymbol.SpecialType) {
                case SpecialType.System_Boolean: paramNameBase = "bool"; break;

                case SpecialType.System_Byte: paramNameBase = "byte"; break;

                case SpecialType.System_SByte: paramNameBase = "sbyte"; break;

                case SpecialType.System_Char: paramNameBase = "char"; break;

                case SpecialType.System_Decimal: paramNameBase = "decimal"; break;

                case SpecialType.System_Double: paramNameBase = "double"; break;

                case SpecialType.System_Single: paramNameBase = "float"; break;

                case SpecialType.System_Int32: paramNameBase = "int"; break;

                case SpecialType.System_UInt32: paramNameBase = "uint"; break;

                case SpecialType.System_Int64: paramNameBase = "long"; break;

                case SpecialType.System_UInt64: paramNameBase = "ulong"; break;

                case SpecialType.System_Int16: paramNameBase = "short"; break;

                case SpecialType.System_UInt16: paramNameBase = "ushort"; break;

                case SpecialType.System_Object: paramNameBase = "object"; break;

                case SpecialType.System_String: paramNameBase = "string"; break;

                default:
                    var cleanTypeName = GetCleanTypeName(typeSymbol);
                    if (string.IsNullOrEmpty(cleanTypeName) || cleanTypeName == "_" || cleanTypeName.EndsWith("Nullable")) {
                        if (cleanTypeName.EndsWith("Nullable")) {
                            // e.g. "IntNullable" -> "intOpt"
                            var baseName = cleanTypeName.Substring(0, cleanTypeName.Length - "Nullable".Length);
                            // Convert baseName (e.g. "Int") to camelCase for the parameter part
                            if (baseName.Length > 0 && char.IsUpper(baseName[0]))
                                baseName = char.ToLowerInvariant(baseName[0]) + baseName.Substring(1);
                            else if (string.IsNullOrEmpty(baseName)) // Should not happen if GetCleanTypeName is robust
                                baseName = "value";

                            paramNameBase = baseName + "Opt";
                        }
                        else {
                            paramNameBase = "arg";
                        }
                    }
                    else if (char.IsUpper(cleanTypeName[0])) {
                        if (cleanTypeName.Length == 1 || (cleanTypeName.Length > 1 && char.IsLower(cleanTypeName[1]))) {
                            paramNameBase = char.ToLowerInvariant(cleanTypeName[0]) + cleanTypeName.Substring(1);
                        }
                        else {
                            var allUpper = true;
                            foreach (var c_ in cleanTypeName)
                                if (char.IsLower(c_)) {
                                    allUpper = false;
                                    break;
                                }

                            if (allUpper)
                                paramNameBase = cleanTypeName.ToLowerInvariant();
                            else
                                paramNameBase = char.ToLowerInvariant(cleanTypeName[0]) + cleanTypeName.Substring(1);
                        }
                    }
                    else {
                        paramNameBase = cleanTypeName;
                    }

                    break;
            }

        if (SyntaxFacts.IsKeywordKind(SyntaxFacts.GetKeywordKind(paramNameBase)) || paramNameBase == "value") return "@" + paramNameBase;

        return paramNameBase;
    }
}
