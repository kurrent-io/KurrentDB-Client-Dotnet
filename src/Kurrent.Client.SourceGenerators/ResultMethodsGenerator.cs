using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Kurrent.Client.SourceGenerators;

[Generator]
public class ResultMethodsGenerator : ISourceGenerator {
    public void Initialize(GeneratorInitializationContext context) {
        // No initialization required
    }

    public void Execute(GeneratorExecutionContext context) {
        var compilation = context.Compilation;

        foreach (var syntaxTree in compilation.SyntaxTrees) {
            var semanticModel = compilation.GetSemanticModel(syntaxTree);
            var root          = syntaxTree.GetRoot();

            foreach (var classDeclaration in root.DescendantNodes().OfType<ClassDeclarationSyntax>()) {
                var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
                if (classSymbol == null) continue;

                if (!InheritsFromResult(classSymbol, out var successType, out var errorType)) continue;

                if (successType == null || errorType == null) continue;

                var source = GenerateSource(classSymbol, successType, errorType);
                if (string.IsNullOrEmpty(source)) continue;

                var fullTypeNameForFile = classSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat).Replace('.', '_');
                context.AddSource($"{classSymbol.ContainingNamespace.ToDisplayString().Replace('.', '_')}_{fullTypeNameForFile}_ResultMethods.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    static bool InheritsFromResult(INamedTypeSymbol classSymbol, out ITypeSymbol? successType, out ITypeSymbol? errorType) {
        successType = null;
        errorType   = null;

        var baseType = classSymbol.BaseType;
        while (baseType != null) {
            if (baseType.IsGenericType &&
                baseType.Name == "Result" &&
                baseType.ContainingNamespace.ToDisplayString() == "Kurrent.Client")
                if (baseType.TypeArguments.Length == 2) {
                    successType = baseType.TypeArguments[0];
                    errorType   = baseType.TypeArguments[1];
                    return true;
                }

            baseType = baseType.BaseType;
        }

        return false;
    }

    static string GenerateSource(INamedTypeSymbol classSymbol, ITypeSymbol successType, ITypeSymbol errorType) {
        var className                   = classSymbol.Name;
        var successTypeName             = successType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var errorTypeName               = errorType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var minimallyQualifiedClassName = classSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : classSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine($"#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName)) {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        var containingTypeSymbols = new List<INamedTypeSymbol>();
        var currentContainingType = classSymbol.ContainingType;
        while (currentContainingType != null) {
            containingTypeSymbols.Add(currentContainingType);
            currentContainingType = currentContainingType.ContainingType;
        }

        containingTypeSymbols.Reverse(); // Outermost to innermost

        // Open containing type declarations
        foreach (var containingTypeSymbol in containingTypeSymbols) {
            sb.AppendLine($"public partial class {containingTypeSymbol.Name}");
            sb.AppendLine("{");
        }

        var baseIndent = string.Concat(Enumerable.Repeat("    ", containingTypeSymbols.Count));

        sb.AppendLine($"{baseIndent}public partial class {className}");
        sb.AppendLine($"{baseIndent}{{");

        var memberIndent = $"{baseIndent}    ";

        // Constructor
        sb.AppendLine($"{memberIndent}protected {className}(bool isSuccess, {successTypeName} success = default, {errorTypeName} error = default)");
        sb.AppendLine($"{memberIndent}    : base(isSuccess, success, error) {{ }}");
        sb.AppendLine();

        // Static Factory Methods
        sb.AppendLine($"{memberIndent}public new static {minimallyQualifiedClassName} Success({successTypeName} success) => new(true, success: success);");
        sb.AppendLine($"{memberIndent}public new static {minimallyQualifiedClassName} Error({errorTypeName} error) => new(false, error: error);");
        sb.AppendLine();

        // Implicit Conversion Operators
        sb.AppendLine($"{memberIndent}public static implicit operator {minimallyQualifiedClassName}({successTypeName} success) => Success(success);");
        sb.AppendLine($"{memberIndent}public static implicit operator {minimallyQualifiedClassName}({errorTypeName} error) => Error(error);");
        sb.AppendLine();

        // Explicit Conversion Operators
        sb.AppendLine($"{memberIndent}public static explicit operator {successTypeName}({minimallyQualifiedClassName} result) => result.AsSuccess;");
        sb.AppendLine($"{memberIndent}public static explicit operator {errorTypeName}({minimallyQualifiedClassName} result) => result.AsError;");

        sb.AppendLine($"{baseIndent}}}"); // Close class {className}

        // Close containing type declarations
        for (var i = containingTypeSymbols.Count - 1; i >= 0; i--)
            sb.AppendLine(string.Concat(Enumerable.Repeat("    ", i)) + "}");

        return sb.ToString();
    }
}
